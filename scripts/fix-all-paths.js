const fs = require('fs');
const path = require('path');
const cheerio = require('cheerio');

// ÈÄíÂΩíÊü•ÊâæÊâÄÊúâHTMLÊñá‰ª∂
function findHtmlFiles(dir, files = []) {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
            findHtmlFiles(fullPath, files);
        } else if (item.endsWith('.html')) {
            files.push(fullPath);
        }
    }
    
    return files;
}

// ‰øÆÂ§çÂçï‰∏™HTMLÊñá‰ª∂ÁöÑË∑ØÂæÑ
function fixHtmlFile(filePath) {
    console.log(`Processing: ${filePath}`);
    
    try {
        const html = fs.readFileSync(filePath, 'utf8');
        const $ = cheerio.load(html);
        let modified = false;
        
        // ‰øÆÂ§çCSSË∑ØÂæÑ
        $('link[rel="stylesheet"]').each((i, el) => {
            const href = $(el).attr('href');
            if (href && !href.startsWith('/') && !href.startsWith('http')) {
                // ËÆ°ÁÆóÁõ∏ÂØπË∑ØÂæÑÂà∞Ê†πÁõÆÂΩïÁöÑÁªùÂØπË∑ØÂæÑ
                const relativePath = path.relative(path.dirname(filePath), 'public');
                const newHref = href.replace(/^(\.\.\/)*/, '/');
                $(el).attr('href', newHref);
                console.log(`  Fixed CSS: ${href} -> ${newHref}`);
                modified = true;
            }
        });
        
        // ‰øÆÂ§çJSË∑ØÂæÑ
        $('script[src]').each((i, el) => {
            const src = $(el).attr('src');
            if (src && !src.startsWith('/') && !src.startsWith('http')) {
                const newSrc = src.replace(/^(\.\.\/)*/, '/');
                $(el).attr('src', newSrc);
                console.log(`  Fixed JS: ${src} -> ${newSrc}`);
                modified = true;
            }
        });
        
        // ‰øÆÂ§çfaviconË∑ØÂæÑ
        $('link[rel="icon"], link[rel="shortcut icon"]').each((i, el) => {
            const href = $(el).attr('href');
            if (href && !href.startsWith('/') && !href.startsWith('http')) {
                const newHref = href.replace(/^(\.\.\/)*/, '/');
                $(el).attr('href', newHref);
                console.log(`  Fixed favicon: ${href} -> ${newHref}`);
                modified = true;
            }
        });
        
        // ‰øÆÂ§çÂõæÁâáË∑ØÂæÑÔºàlogoÁ≠âÔºâ
        $('img[src]').each((i, el) => {
            const src = $(el).attr('src');
            if (src && !src.startsWith('/') && !src.startsWith('http') && !src.startsWith('data:')) {
                const newSrc = src.replace(/^(\.\.\/)*/, '/');
                $(el).attr('src', newSrc);
                console.log(`  Fixed image: ${src} -> ${newSrc}`);
                modified = true;
            }
        });
        
        if (modified) {
            fs.writeFileSync(filePath, $.html());
            console.log(`  ‚úÖ Updated: ${filePath}`);
        } else {
            console.log(`  ‚è≠Ô∏è  No changes needed: ${filePath}`);
        }
        
    } catch (error) {
        console.error(`  ‚ùå Error processing ${filePath}:`, error.message);
    }
}

// ‰∏ªÂáΩÊï∞
function main() {
    console.log('üîß Starting path fix for all HTML files...\n');
    
    const publicDir = path.join(__dirname, '..', 'public');
    const htmlFiles = findHtmlFiles(publicDir);
    
    console.log(`üìÅ Found ${htmlFiles.length} HTML files to process\n`);
    
    let processed = 0;
    let updated = 0;
    
    for (const file of htmlFiles) {
        const originalContent = fs.readFileSync(file, 'utf8');
        fixHtmlFile(file);
        
        const newContent = fs.readFileSync(file, 'utf8');
        if (originalContent !== newContent) {
            updated++;
        }
        processed++;
    }
    
    console.log(`\nüéâ Path fix completed!`);
    console.log(`üìä Processed: ${processed} files`);
    console.log(`‚úÖ Updated: ${updated} files`);
}

if (require.main === module) {
    main();
}

module.exports = { findHtmlFiles, fixHtmlFile }; 